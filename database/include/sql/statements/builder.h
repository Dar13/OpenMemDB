/* Copyright (c) 2016 Neil Moore, Jason Stavrinaky, Micheal McGee, Robert Medina
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this 
 * software and associated documentation files (the "Software"), to deal in the Software 
 * without restriction, including without limitation the rights to use, copy, modify, 
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies 
 * or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SQL_BUILDER_H
#define SQL_BUILDER_H

// C++ standard library includes
#include <string>

// C standard library includes
#include <cstdint>

// Project includes
#include "../common.h"
#include "data_definition.h"
#include "data_manipulation.h"

#include "util/types.h"

// Forward declaration
class DataStore;

/**
 * \brief The object that assists the parser in converting SQL statements into an
 * internal representation suitable for execution by the database.
 */
struct StatementBuilder
{
    StatementBuilder()
        : started(false), valid(false), statement(nullptr),
          expr(nullptr)
    {}
  
    //! If true then the builder is in the middle of building a statement
    bool started;

    //! If true, then the builder's parsed statement is valid SQL
    bool valid;

    //! Vector to temporarily hold a columns' constraints.
    std::vector<SQLConstraint> temp_constraints;

    //! The internal representation of a SQL statement
    ParsedStatement* statement;

    //! The expression tree generated by the parser
    Expression* expr;

    //! A reference to the current \refer DataStore object
    DataStore* data_store;
};

// Table management functions
void builderStartCreateTable(StatementBuilder* builder, Token table_name);
void builderStartDropTable(StatementBuilder* builder, Token table_name);
void builderAddColumnConstraint(StatementBuilder* builder, SQLConstraintType type,
        Token value = nullptr);

// Query management function
void builderStartSelectQuery(StatementBuilder* builder);
void builderAddSelectAllColumns(StatementBuilder* builder, Token table);
void builderAddQualifiedSelectColumn(StatementBuilder* builder,
                                     Token table, Token source_column,
                                     Token output_column);
void builderFinishSelectQuery(StatementBuilder* builder);

// Insert command functions
void builderStartInsertCommand(StatementBuilder* builder);
void builderAddDataItem(StatementBuilder* builder, Token data);
void builderFinishInsertcommand(StatementBuilder* builder);

// Update command functions
void builderAddUpdateExpr(StatementBuilder* builder, Token operation,
        Token left, Token right);
void builderFinishUpdateCommand(StatementBuilder* builder);

// Somewhat generic helper functions
void builderAddColumn(StatementBuilder* builder, 
                      Token column_name, 
                      Token column_type, 
                      Token column_constraints);
void builderAddColumnName(StatementBuilder* builder, Token column_name);
void builderAddColumnType(StatementBuilder* builder, Token column_type);
void builderAddTableName(StatementBuilder* builder, Token table_name);
void builderStartNestedExpr(StatementBuilder* builder, Token operation);
void builderAddValueExpr(StatementBuilder* builder,
        Token operation, Token left_term, Token right_term);

// Overall builder management
void builderClean(StatementBuilder* builder);

#endif
