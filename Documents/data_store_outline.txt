Data Store:
Data Store receives data requests and based on those requests will return a subset of data from
the database. This database will represent data in a table format using nested vectors. Each table
will be stored in a table hashmap to allow for easy table lookup. Each table contains a relational
schema for the type of data each column can accept. This is represented as a pair in the table 
lookup hashmap. 

*Table into nested vectors*

*Table lookup hashmap with relational schema*

Nested vectors are stored as row store architecture and column store architecture.

*row store architecture: row_store_ex*

*column store architecture: column_store_ex*

*row_store_and_column_ex*

Whenever a data request inquires about a table or more the data store will return a subset of that
data in the form of nested vectors. It looks up the table that in memory as shown below.

Tables stored in the RAM:
*table lookup from memory picture: abstract_tables_in_memory*

Table Hashmap Lookup:
*table lookup hash example: my_picture*

Row Store vs Column Store
Column Store:
The advantage of column based tables are faster data access, better compression, and better parallel processing.
In order to change a column from a row store architecture, each row in the table must be search in order to find the
column and then it requires to change the value. This makes it slow to check for integrity constraints. Column store 
is a simply search through one vector row or column. Column vectors are very similar to each other value, which allows
for easy compression of data, unlike row vectors which could contain many different data types. In column store, data
is already partition into seperate columns so each column can be processed by itself. 

Row Store:
The advantages of row based tables are easy row inserts into tables, and easy row access. This is useful when a query
wants to manipulate the entire row data instead of a few columns. In column store this would require multiple column vectors
being rewritten and maniuplated which would be a costly operation to perform. 

*example of query for row and column store: query_of_table_ex*
Seeing in the row store and column store figure previously, it would be
difficult to find the sales column in a row store column, and it is easily
noticeable to see how adding a new row in column store would require multiple
access to multiple column vectors.

*
Tervel Data Structures
Row Store Architecture
Hash-Based Indexing
REMOVE: Transaction Manager?? (Should I only apply COMMIT?)
REMOVE: Logger?? (Should I log the transactions in a stack?? what will the logs be used for?)
Snapshot Isolation (Should the database be backed up to disk??)
*

ACID:
Properties of a reliable database is outline as ACID. In order to guarantee that 
database transactions are processed reliably a database must have atomicity, consistency,
isolation and durability. 

Atomicity refers to the ability of a database to guarantee that all transactions
are performed or none of them are. Transactions that abort operations midway leaves
for data inconsistency. In the event that a transaction is aborted then the database 
returns to the last commited transaction state.

Consistency refers to the ability of a transaction to take the database from one valid state
to another. Before a transaction and after a transaction the database must remain in a valid state.
Any data written to the database must be valid according to any constraints, cascades and triggers. 

Isolation refers to the level of visibility of transactions to other users or systems. In other words,
transactions from two users cannot interact with one another and if two concurrent transactions occur then
those changes to the state of the database are not reflected to each other user. If those transactions occur
concurrently and rely on each other then locking will occur.

Durability means that once a transaction is commited then those changes on the database will be reflected to the user
and will be recorded pernamently. This is usually performed by backing up valid states of the database. 

*
A-Log Manager (need disk to log pages)
C-Constraint Checker Function (enum datatypes added to relational schema)
I-tervel wait-free property
D-(need disk to snapshot db)
*
*
Features to illistrate, must write and add diagrams for each feature:
CRUD-style queries (CREATE TABLE, INSERT, SELECT, UPDATE, DELETE, DROP TABLE)
Table constraints (PRIMARY KEY, NOT NULL, DEFAULT, FOREIGN KEY, UNIQUE, AUTO_INCREMENT)
Limited Datatypes (INTEGER, BOOLEAN, CHAR/VARCHAR, FLOAT, DATE, TIME, TIMESTAMP)
Joins(?)
Subqueries(tentatively), with EXISTS/NOT EXISTS contingent on this
WHERE, ORDER BY, GROUP BY, IN, BETWEEN,
ODBC implementation
UNION(?)
Aliases(?)
Boolean expressions
Regex (LIKE, wildcards, etc)(?)
Math aggregate functions (MAX, MIN, AVG, COUNT, SUM)
*
*Constraint checker function write up with diagram(simple hashmap):
...
*
